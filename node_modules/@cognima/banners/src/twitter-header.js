"use strict";

/**
 * M√≥dulo de Banner de Cabe√ßalho do Twitter
 * 
 * Este m√≥dulo gera banners no estilo de cabe√ßalho de perfil do Twitter com
 * imagem de capa, avatar, nome, username, bio e estat√≠sticas.
 * 
 * @author Cognima Team (melhorado)
 * @version 2.0.0
 */

Object.defineProperty(exports, "__esModule", { value: true });

const pureimage = require("pureimage");
const path = require("path");
const {
    loadImageWithAxios,
    encodeToBuffer,
    roundRect,
    wrapText,
    registerFontIfNeeded,
    isValidHexColor,
    DEFAULT_FONT_FAMILY,
    applyTextShadow,
    clearShadow,
    createLinearGradient,
    hexToRgba,
    formatNumber
} = require("../utils");

const {
    DEFAULT_COLORS,
    LAYOUT,
    DEFAULT_DIMENSIONS
} = require("./constants");

/**
 * @class TwitterHeader
 * @classdesc Gera um banner no estilo de cabe√ßalho de perfil do Twitter.
 * @example const header = new TwitterHeader()
 * .setName("Nome Completo")
 * .setUsername("usuario")
 * .setBio("Desenvolvedor | Designer | Criador de conte√∫do")
 * .setAvatar("avatar.png")
 * .setCoverImage("cover.jpg")
 * .setFollowers(5200)
 * .setFollowing(420)
 * .setVerified(true)
 * .build();
 */
module.exports = class TwitterHeader {
  constructor(options) {
    // Dados Principais
    this.name = "Nome Completo";
    this.username = "usuario";
    this.bio = null;
    this.location = null;
    this.website = null;
    this.joinDate = null;
    this.avatar = null;
    this.coverImage = null;
    this.followers = 0;
    this.following = 0;
    this.tweets = 0;
    this.isVerified = false;
    this.isPremium = false;

    // Personaliza√ß√£o Visual
    this.font = { name: options?.font?.name ?? DEFAULT_FONT_FAMILY, path: options?.font?.path };
    this.theme = "light"; // light, dark, dim
    this.accentColor = DEFAULT_COLORS.twitter.primary;
    this.useTextShadow = false;
    this.useDarkMode = false;
    
    // Configura√ß√µes de Layout
    this.cardWidth = DEFAULT_DIMENSIONS.banner.width;
    this.cardHeight = 400;
    this.avatarSize = 120;
  }

  // --- Setters para Dados Principais ---
  /**
   * Define o nome completo
   * @param {string} text - Nome completo
   * @returns {TwitterHeader} - Inst√¢ncia atual para encadeamento
   */
  setName(text) { 
    if (!text || typeof text !== "string") throw new Error("O nome completo deve ser uma string n√£o vazia."); 
    this.name = text; 
    return this; 
  }
  
  /**
   * Define o nome de usu√°rio
   * @param {string} text - Nome de usu√°rio (sem @)
   * @returns {TwitterHeader} - Inst√¢ncia atual para encadeamento
   */
  setUsername(text) { 
    if (!text || typeof text !== "string") throw new Error("O nome de usu√°rio deve ser uma string n√£o vazia."); 
    this.username = text.replace(/^@/, ''); // Remove @ se presente
    return this; 
  }
  
  /**
   * Define a bio
   * @param {string} text - Texto da bio
   * @returns {TwitterHeader} - Inst√¢ncia atual para encadeamento
   */
  setBio(text) {
    if (!text || typeof text !== "string") throw new Error("A bio deve ser uma string n√£o vazia.");
    this.bio = text;
    return this;
  }
  
  /**
   * Define a localiza√ß√£o
   * @param {string} text - Texto da localiza√ß√£o
   * @returns {TwitterHeader} - Inst√¢ncia atual para encadeamento
   */
  setLocation(text) {
    if (!text || typeof text !== "string") throw new Error("A localiza√ß√£o deve ser uma string n√£o vazia.");
    this.location = text;
    return this;
  }
  
  /**
   * Define o website
   * @param {string} text - URL do website
   * @returns {TwitterHeader} - Inst√¢ncia atual para encadeamento
   */
  setWebsite(text) {
    if (!text || typeof text !== "string") throw new Error("O website deve ser uma string n√£o vazia.");
    this.website = text;
    return this;
  }
  
  /**
   * Define a data de entrada
   * @param {string} text - Data de entrada (ex: "Entrou em maio de 2020")
   * @returns {TwitterHeader} - Inst√¢ncia atual para encadeamento
   */
  setJoinDate(text) {
    if (!text || typeof text !== "string") throw new Error("A data de entrada deve ser uma string n√£o vazia.");
    this.joinDate = text;
    return this;
  }
  
  /**
   * Define o avatar
   * @param {string|Buffer|Object} image - URL, Buffer ou caminho da imagem do avatar
   * @returns {TwitterHeader} - Inst√¢ncia atual para encadeamento
   */
  setAvatar(image) {
    if (!image) throw new Error("A fonte da imagem do avatar n√£o pode estar vazia.");
    this.avatar = image;
    return this;
  }
  
  /**
   * Define a imagem de capa
   * @param {string|Buffer|Object} image - URL, Buffer ou caminho da imagem de capa
   * @returns {TwitterHeader} - Inst√¢ncia atual para encadeamento
   */
  setCoverImage(image) {
    if (!image) throw new Error("A fonte da imagem de capa n√£o pode estar vazia.");
    this.coverImage = image;
    return this;
  }
  
  /**
   * Define o n√∫mero de seguidores
   * @param {number} count - N√∫mero de seguidores
   * @returns {TwitterHeader} - Inst√¢ncia atual para encadeamento
   */
  setFollowers(count) {
    if (typeof count !== "number" || count < 0) throw new Error("O n√∫mero de seguidores deve ser um n√∫mero n√£o negativo.");
    this.followers = count;
    return this;
  }
  
  /**
   * Define o n√∫mero de pessoas seguidas
   * @param {number} count - N√∫mero de pessoas seguidas
   * @returns {TwitterHeader} - Inst√¢ncia atual para encadeamento
   */
  setFollowing(count) {
    if (typeof count !== "number" || count < 0) throw new Error("O n√∫mero de pessoas seguidas deve ser um n√∫mero n√£o negativo.");
    this.following = count;
    return this;
  }
  
  /**
   * Define o n√∫mero de tweets
   * @param {number} count - N√∫mero de tweets
   * @returns {TwitterHeader} - Inst√¢ncia atual para encadeamento
   */
  setTweets(count) {
    if (typeof count !== "number" || count < 0) throw new Error("O n√∫mero de tweets deve ser um n√∫mero n√£o negativo.");
    this.tweets = count;
    return this;
  }
  
  /**
   * Define se o perfil √© verificado
   * @param {boolean} isVerified - Se o perfil √© verificado
   * @returns {TwitterHeader} - Inst√¢ncia atual para encadeamento
   */
  setVerified(isVerified = true) {
    this.isVerified = !!isVerified;
    return this;
  }
  
  /**
   * Define se o perfil √© premium
   * @param {boolean} isPremium - Se o perfil √© premium
   * @returns {TwitterHeader} - Inst√¢ncia atual para encadeamento
   */
  setPremium(isPremium = true) {
    this.isPremium = !!isPremium;
    return this;
  }

  // --- Setters para Personaliza√ß√£o Visual ---
  /**
   * Define o tema
   * @param {string} theme - Tema ('light', 'dark', 'dim')
   * @returns {TwitterHeader} - Inst√¢ncia atual para encadeamento
   */
  setTheme(theme) {
    const validThemes = ["light", "dark", "dim"];
    if (!theme || !validThemes.includes(theme.toLowerCase())) {
      throw new Error(`Tema inv√°lido. Use um dos seguintes: ${validThemes.join(", ")}`);
    }
    
    this.theme = theme.toLowerCase();
    return this;
  }
  
  /**
   * Define a cor de destaque
   * @param {string} color - Cor hexadecimal
   * @returns {TwitterHeader} - Inst√¢ncia atual para encadeamento
   */
  setAccentColor(color) { 
    if (!color || !isValidHexColor(color)) throw new Error("Cor de destaque inv√°lida. Use o formato hexadecimal."); 
    this.accentColor = color; 
    return this; 
  }
  
  /**
   * Ativa ou desativa a sombra de texto
   * @param {boolean} enabled - Se a sombra de texto deve ser ativada
   * @returns {TwitterHeader} - Inst√¢ncia atual para encadeamento
   */
  enableTextShadow(enabled = true) {
    this.useTextShadow = enabled;
    return this;
  }
  
  /**
   * Ativa ou desativa o modo escuro
   * @param {boolean} enabled - Se o modo escuro deve ser ativado
   * @returns {TwitterHeader} - Inst√¢ncia atual para encadeamento
   */
  enableDarkMode(enabled = true) {
    this.useDarkMode = enabled;
    this.theme = enabled ? "dark" : "light";
    return this;
  }
  
  /**
   * Define as dimens√µes do card
   * @param {number} width - Largura do card em pixels
   * @param {number} height - Altura do card em pixels
   * @returns {TwitterHeader} - Inst√¢ncia atual para encadeamento
   */
  setCardDimensions(width, height) {
    if (typeof width !== "number" || width < 600 || width > 1920) {
      throw new Error("A largura do card deve estar entre 600 e 1920 pixels.");
    }
    
    if (typeof height !== "number" || height < 300 || height > 800) {
      throw new Error("A altura do card deve estar entre 300 e 800 pixels.");
    }
    
    this.cardWidth = width;
    this.cardHeight = height;
    
    return this;
  }
  
  /**
   * Define o tamanho do avatar
   * @param {number} size - Tamanho do avatar em pixels
   * @returns {TwitterHeader} - Inst√¢ncia atual para encadeamento
   */
  setAvatarSize(size) {
    if (typeof size !== "number" || size < 80 || size > 200) {
      throw new Error("O tamanho do avatar deve estar entre 80 e 200 pixels.");
    }
    
    this.avatarSize = size;
    return this;
  }

  // --- M√©todo de Constru√ß√£o ---
  /**
   * Constr√≥i o banner e retorna um buffer de imagem
   * @returns {Promise<Buffer>} - Buffer contendo a imagem do banner
   */
  async build() {
    // --- Registro de Fonte ---
    const registeredFontName = await registerFontIfNeeded(this.font);

    // --- Configura√ß√£o do Canvas ---
    const cardWidth = this.cardWidth;
    const cardHeight = this.cardHeight;
    const coverHeight = cardHeight * 0.5;
    const avatarSize = this.avatarSize;
    const padding = 20;

    const canvas = pureimage.make(cardWidth, cardHeight);
    const ctx = canvas.getContext("2d");

    // --- Configura√ß√£o de Cores com base no Tema ---
    const colors = this._getThemeColors();

    // --- Desenha Plano de Fundo ---
    ctx.fillStyle = colors.background;
    ctx.fillRect(0, 0, cardWidth, cardHeight);

    // --- Desenha Imagem de Capa ---
    if (this.coverImage) {
      try {
        const img = await loadImageWithAxios(this.coverImage);
        const aspect = img.width / img.height;
        let drawWidth = cardWidth; 
        let drawHeight = cardWidth / aspect;
        
        // Ajusta as dimens√µes para cobrir toda a √°rea da capa
        if (drawHeight < coverHeight) { 
          drawHeight = coverHeight; 
          drawWidth = coverHeight * aspect; 
        }
        
        const offsetX = (cardWidth - drawWidth) / 2; 
        const offsetY = 0;
        
        ctx.drawImage(img, offsetX, offsetY, drawWidth, coverHeight);
      } catch (e) {
        console.error("Falha ao desenhar imagem de capa:", e.message);
        
        // Capa de fallback
        ctx.fillStyle = this.accentColor;
        ctx.fillRect(0, 0, cardWidth, coverHeight);
      }
    } else {
      // Capa de fallback
      ctx.fillStyle = this.accentColor;
      ctx.fillRect(0, 0, cardWidth, coverHeight);
    }

    // --- Desenha Avatar ---
    const avatarX = padding;
    const avatarY = coverHeight - avatarSize / 2;
    
    ctx.save();
    ctx.beginPath();
    ctx.arc(avatarX + avatarSize / 2, avatarY + avatarSize / 2, avatarSize / 2, 0, Math.PI * 2);
    ctx.closePath();
    ctx.clip();
    
    try {
      const avatarImg = await loadImageWithAxios(this.avatar || path.join(__dirname, "../assets/placeholders/avatar.png"));
      ctx.drawImage(avatarImg, avatarX, avatarY, avatarSize, avatarSize);
    } catch (e) {
      console.error("Falha ao desenhar avatar:", e.message);
      
      // Avatar de fallback
      ctx.fillStyle = colors.secondary;
      ctx.fillRect(avatarX, avatarY, avatarSize, avatarSize);
      
      ctx.fillStyle = colors.text;
      ctx.font = `bold ${avatarSize / 3}px ${registeredFontName}-Bold`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(this.name.charAt(0).toUpperCase(), avatarX + avatarSize / 2, avatarY + avatarSize / 2);
    }
    
    ctx.restore();
    
    // Borda do avatar
    ctx.strokeStyle = colors.background;
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.arc(avatarX + avatarSize / 2, avatarY + avatarSize / 2, avatarSize / 2 + ctx.lineWidth / 2, 0, Math.PI * 2);
    ctx.stroke();
    ctx.closePath();

    // --- Desenha Bot√£o de Seguir ---
    const followButtonWidth = 120;
    const followButtonHeight = 40;
    const followButtonX = cardWidth - followButtonWidth - padding;
    const followButtonY = coverHeight + padding;
    
    // Fundo do bot√£o
    ctx.fillStyle = colors.text;
    roundRect(ctx, followButtonX, followButtonY, followButtonWidth, followButtonHeight, 20, true, false);
    
    // Texto do bot√£o
    ctx.fillStyle = colors.background;
    ctx.font = `bold 16px ${registeredFontName}-Bold`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("Seguir", followButtonX + followButtonWidth / 2, followButtonY + followButtonHeight / 2);

    // --- Desenha Nome e Username ---
    const nameX = padding;
    const nameY = coverHeight + avatarSize / 2 + padding;
    
    // Nome
    ctx.fillStyle = colors.text;
    ctx.font = `bold 24px ${registeredFontName}-Bold`;
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    
    // Aplica sombra de texto se ativada
    if (this.useTextShadow) {
      applyTextShadow(ctx, hexToRgba(colors.shadow, 0.5), 2, 1, 1);
    }
    
    const nameText = this.name;
    const nameWidth = ctx.measureText(nameText).width;
    ctx.fillText(nameText, nameX, nameY);
    
    // Desenha √≠cone de verificado (se aplic√°vel)
    if (this.isVerified) {
      const verifiedSize = 20;
      const verifiedX = nameX + nameWidth + 5;
      
      ctx.fillStyle = this.isPremium ? "#FFD700" : this.accentColor;
      ctx.beginPath();
      ctx.arc(verifiedX + verifiedSize / 2, nameY + 12, verifiedSize / 2, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.fillStyle = "#FFFFFF";
      ctx.font = `bold 14px ${registeredFontName}-Bold`;
      ctx.textAlign = "center";
      ctx.fillText("‚úì", verifiedX + verifiedSize / 2, nameY + 12);
    }
    
    // Remove sombra para o pr√≥ximo texto
    if (this.useTextShadow) {
      clearShadow(ctx);
    }
    
    // Username
    ctx.fillStyle = colors.textSecondary;
    ctx.font = `regular 16px ${registeredFontName}-Regular`;
    ctx.textAlign = "left";
    ctx.fillText(`@${this.username}`, nameX, nameY + 30);

    // --- Desenha Bio ---
    if (this.bio) {
      ctx.fillStyle = colors.text;
      ctx.font = `regular 16px ${registeredFontName}-Regular`;
      ctx.textAlign = "left";
      
      const bioY = nameY + 60;
      wrapText(ctx, this.bio, nameX, bioY, cardWidth - padding * 2, 20, registeredFontName);
    }

    // --- Desenha Informa√ß√µes Adicionais ---
    const infoY = nameY + (this.bio ? 120 : 70);
    let infoX = nameX;
    const infoSpacing = 20;
    
    // Localiza√ß√£o
    if (this.location) {
      ctx.fillStyle = colors.textSecondary;
      ctx.font = `regular 14px ${registeredFontName}-Regular`;
      ctx.textAlign = "left";
      
      const locationText = `üìç ${this.location}`;
      ctx.fillText(locationText, infoX, infoY);
      
      infoX += ctx.measureText(locationText).width + infoSpacing;
    }
    
    // Website
    if (this.website) {
      ctx.fillStyle = this.accentColor;
      ctx.font = `regular 14px ${registeredFontName}-Regular`;
      ctx.textAlign = "left";
      
      const websiteText = `üîó ${this.website}`;
      ctx.fillText(websiteText, infoX, infoY);
      
      infoX += ctx.measureText(websiteText).width + infoSpacing;
    }
    
    // Data de entrada
    if (this.joinDate) {
      ctx.fillStyle = colors.textSecondary;
      ctx.font = `regular 14px ${registeredFontName}-Regular`;
      ctx.textAlign = "left";
      
      const joinDateText = `üóìÔ∏è ${this.joinDate}`;
      ctx.fillText(joinDateText, infoX, infoY);
    }

    // --- Desenha Estat√≠sticas ---
    const statsY = infoY + 30;
    let statsX = nameX;
    const statsSpacing = 30;
    
    // Seguidores
    ctx.fillStyle = colors.text;
    ctx.font = `bold 14px ${registeredFontName}-Bold`;
    ctx.textAlign = "left";
    
    const followersText = `${formatNumber(this.followers)}`;
    ctx.fillText(followersText, statsX, statsY);
    
    ctx.fillStyle = colors.textSecondary;
    ctx.font = `regular 14px ${registeredFontName}-Regular`;
    const followersLabelWidth = ctx.measureText(" Seguidores").width;
    ctx.fillText(" Seguidores", statsX + ctx.measureText(followersText).width, statsY);
    
    statsX += ctx.measureText(followersText).width + followersLabelWidth + statsSpacing;
    
    // Seguindo
    ctx.fillStyle = colors.text;
    ctx.font = `bold 14px ${registeredFontName}-Bold`;
    
    const followingText = `${formatNumber(this.following)}`;
    ctx.fillText(followingText, statsX, statsY);
    
    ctx.fillStyle = colors.textSecondary;
    ctx.font = `regular 14px ${registeredFontName}-Regular`;
    const followingLabelWidth = ctx.measureText(" Seguindo").width;
    ctx.fillText(" Seguindo", statsX + ctx.measureText(followingText).width, statsY);
    
    statsX += ctx.measureText(followingText).width + followingLabelWidth + statsSpacing;
    
    // Tweets
    if (this.tweets > 0) {
      ctx.fillStyle = colors.text;
      ctx.font = `bold 14px ${registeredFontName}-Bold`;
      
      const tweetsText = `${formatNumber(this.tweets)}`;
      ctx.fillText(tweetsText, statsX, statsY);
      
      ctx.fillStyle = colors.textSecondary;
      ctx.font = `regular 14px ${registeredFontName}-Regular`;
      ctx.fillText(" Tweets", statsX + ctx.measureText(tweetsText).width, statsY);
    }

    // --- Codifica e Retorna Buffer ---
    try {
      return await encodeToBuffer(canvas);
    } catch (err) {
      console.error("Falha ao codificar o Cabe√ßalho do Twitter:", err);
      throw new Error("N√£o foi poss√≠vel gerar o buffer de imagem do Cabe√ßalho do Twitter.");
    }
  }
  
  // --- M√©todos Auxiliares Privados ---
  /**
   * Obt√©m as cores com base no tema selecionado
   * @private
   */
  _getThemeColors() {
    switch (this.theme) {
      case "dark":
        return {
          background: "#000000",
          secondary: "#16181c",
          text: "#FFFFFF",
          textSecondary: "#8B98A5",
          shadow: "#000000"
        };
      case "dim":
        return {
          background: "#15202B",
          secondary: "#1E2732",
          text: "#FFFFFF",
          textSecondary: "#8B98A5",
          shadow: "#10171E"
        };
      case "light":
      default:
        return {
          background: "#FFFFFF",
          secondary: "#F7F9FA",
          text: "#0F1419",
          textSecondary: "#536471",
          shadow: "#CCCCCC"
        };
    }
  }
};

