"use strict";

/**
 * Módulo de otimização de performance
 * 
 * Este módulo fornece funções para otimizar a performance do módulo @cognima/banners.
 * 
 * @module performance-optimizer
 * @author Cognima Team (melhorado)
 * @version 2.0.0
 */

// Configuração padrão
let config = {
    enabled: true,
    imageResizeThreshold: 2000, // Tamanho máximo de imagem em pixels (largura ou altura)
    imageQualityFactor: 0.9, // Fator de qualidade para compressão de imagens
    useWebWorkers: true, // Se deve usar Web Workers para processamento paralelo
    maxConcurrentOperations: 4, // Número máximo de operações concorrentes
    useMemoryOptimization: true, // Se deve otimizar o uso de memória
    garbageCollectionInterval: 10, // Intervalo para coleta de lixo (em operações)
    operationCount: 0 // Contador de operações
};

/**
 * Otimiza uma imagem para melhor performance
 * 
 * @param {Object} image - Objeto de imagem
 * @returns {Object} - Imagem otimizada
 */
function optimizeImage(image) {
    if (!config.enabled) return image;
    
    try {
        // Verifica se a imagem precisa ser redimensionada
        if (image.width > config.imageResizeThreshold || image.height > config.imageResizeThreshold) {
            // Calcula as novas dimensões mantendo a proporção
            let newWidth, newHeight;
            
            if (image.width > image.height) {
                newWidth = config.imageResizeThreshold;
                newHeight = Math.round(image.height * (config.imageResizeThreshold / image.width));
            } else {
                newHeight = config.imageResizeThreshold;
                newWidth = Math.round(image.width * (config.imageResizeThreshold / image.height));
            }
            
            // Redimensiona a imagem
            const PImage = require('pureimage');
            const resizedImage = PImage.make(newWidth, newHeight);
            const ctx = resizedImage.getContext('2d');
            
            ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, newWidth, newHeight);
            
            return resizedImage;
        }
        
        return image;
    } catch (error) {
        console.error('Erro ao otimizar imagem:', error);
        return image;
    }
}

/**
 * Otimiza o uso de memória
 */
function optimizeMemory() {
    if (!config.enabled || !config.useMemoryOptimization) return;
    
    config.operationCount++;
    
    // Executa coleta de lixo a cada intervalo definido
    if (config.operationCount % config.garbageCollectionInterval === 0) {
        if (global.gc) {
            try {
                global.gc();
            } catch (error) {
                console.error('Erro ao executar coleta de lixo:', error);
            }
        }
    }
}

/**
 * Otimiza uma operação assíncrona
 * 
 * @param {Function} operation - Função de operação
 * @param {Array} args - Argumentos para a operação
 * @returns {Promise<any>} - Resultado da operação
 */
async function optimizeAsyncOperation(operation, args) {
    if (!config.enabled) return operation(...args);
    
    try {
        // Executa a operação
        const result = await operation(...args);
        
        // Otimiza o uso de memória
        optimizeMemory();
        
        return result;
    } catch (error) {
        console.error('Erro ao executar operação assíncrona:', error);
        throw error;
    }
}

/**
 * Otimiza múltiplas operações assíncronas
 * 
 * @param {Array<Function>} operations - Array de funções de operação
 * @param {Array<Array>} argsArray - Array de arrays de argumentos para cada operação
 * @returns {Promise<Array<any>>} - Array de resultados das operações
 */
async function optimizeMultipleAsyncOperations(operations, argsArray) {
    if (!config.enabled || !config.useWebWorkers) {
        // Executa as operações sequencialmente
        const results = [];
        
        for (let i = 0; i < operations.length; i++) {
            results.push(await operations[i](...argsArray[i]));
        }
        
        return results;
    }
    
    try {
        // Executa as operações em lotes para limitar a concorrência
        const results = [];
        
        for (let i = 0; i < operations.length; i += config.maxConcurrentOperations) {
            const batch = operations.slice(i, i + config.maxConcurrentOperations);
            const batchArgs = argsArray.slice(i, i + config.maxConcurrentOperations);
            
            const batchPromises = batch.map((operation, index) => {
                return operation(...batchArgs[index]);
            });
            
            const batchResults = await Promise.all(batchPromises);
            results.push(...batchResults);
            
            // Otimiza o uso de memória após cada lote
            optimizeMemory();
        }
        
        return results;
    } catch (error) {
        console.error('Erro ao executar múltiplas operações assíncronas:', error);
        throw error;
    }
}

/**
 * Otimiza o buffer de uma imagem
 * 
 * @param {Buffer} buffer - Buffer da imagem
 * @returns {Buffer} - Buffer otimizado
 */
function optimizeBuffer(buffer) {
    if (!config.enabled) return buffer;
    
    try {
        // Implementação simplificada - em um cenário real, usaria bibliotecas como sharp ou imagemin
        return buffer;
    } catch (error) {
        console.error('Erro ao otimizar buffer:', error);
        return buffer;
    }
}

/**
 * Define se a otimização está habilitada
 * 
 * @param {boolean} enabled - Se a otimização está habilitada
 */
function setEnabled(enabled) {
    config.enabled = enabled;
}

/**
 * Configura as opções de otimização
 * 
 * @param {Object} options - Opções de configuração
 * @param {boolean} [options.enabled] - Se a otimização está habilitada
 * @param {number} [options.imageResizeThreshold] - Tamanho máximo de imagem em pixels
 * @param {number} [options.imageQualityFactor] - Fator de qualidade para compressão de imagens
 * @param {boolean} [options.useWebWorkers] - Se deve usar Web Workers
 * @param {number} [options.maxConcurrentOperations] - Número máximo de operações concorrentes
 * @param {boolean} [options.useMemoryOptimization] - Se deve otimizar o uso de memória
 * @param {number} [options.garbageCollectionInterval] - Intervalo para coleta de lixo
 */
function configure(options) {
    config = { ...config, ...options };
}

/**
 * Obtém a configuração atual
 * 
 * @returns {Object} - Configuração atual
 */
function getConfig() {
    return { ...config };
}

module.exports = {
    optimizeImage,
    optimizeAsyncOperation,
    optimizeMultipleAsyncOperations,
    optimizeBuffer,
    optimizeMemory,
    setEnabled,
    configure,
    getConfig
};

