"use strict";

/**
 * Módulo de Execução de Testes
 * 
 * Este módulo fornece funcionalidades para testar automaticamente
 * os diferentes componentes do módulo de banners.
 * 
 * @author Cognima Team (melhorado)
 * @version 2.0.0
 */

Object.defineProperty(exports, "__esModule", { value: true });

const fs = require("fs");
const path = require("path");
const { loadImageWithAxios, encodeToBuffer } = require("../utils");
const ErrorHandler = require("./error-handler");

/**
 * Classe para execução de testes
 */
class TestRunner {
  /**
   * Cria uma nova instância do executor de testes
   * @param {Object} options - Opções de configuração
   */
  constructor(options = {}) {
    this.outputDir = options.outputDir || path.join(process.cwd(), "test-output");
    this.errorHandler = new ErrorHandler(options.errorHandler);
    this.tests = new Map();
    this.testResults = [];
    this.verbose = options.verbose !== false;
    this.stopOnError = options.stopOnError === true;
    
    // Cria o diretório de saída se não existir
    if (!fs.existsSync(this.outputDir)) {
      try {
        fs.mkdirSync(this.outputDir, { recursive: true });
      } catch (err) {
        console.error("Falha ao criar diretório de saída:", err.message);
      }
    }
  }
  
  /**
   * Registra um teste
   * @param {string} name - Nome do teste
   * @param {Function} testFn - Função de teste
   * @param {Object} options - Opções do teste
   */
  registerTest(name, testFn, options = {}) {
    this.tests.set(name, {
      name,
      fn: testFn,
      options: {
        timeout: options.timeout || 30000,
        skip: options.skip === true,
        only: options.only === true,
        category: options.category || "general"
      }
    });
  }
  
  /**
   * Registra um conjunto de testes
   * @param {Object} tests - Objeto com testes
   */
  registerTests(tests) {
    for (const [name, test] of Object.entries(tests)) {
      this.registerTest(name, test.fn, test.options);
    }
  }
  
  /**
   * Executa todos os testes registrados
   * @param {Object} options - Opções de execução
   * @returns {Promise<Object>} - Resultados dos testes
   */
  async runTests(options = {}) {
    const {
      filter = null,
      category = null,
      parallel = false,
      concurrency = 5
    } = options;
    
    this.testResults = [];
    
    // Filtra os testes a serem executados
    let testsToRun = Array.from(this.tests.values());
    
    // Verifica se há testes marcados como "only"
    const onlyTests = testsToRun.filter(test => test.options.only);
    
    if (onlyTests.length > 0) {
      testsToRun = onlyTests;
    }
    
    // Filtra por nome
    if (filter) {
      const filterRegex = new RegExp(filter, "i");
      testsToRun = testsToRun.filter(test => filterRegex.test(test.name));
    }
    
    // Filtra por categoria
    if (category) {
      testsToRun = testsToRun.filter(test => test.options.category === category);
    }
    
    // Remove testes marcados como "skip"
    testsToRun = testsToRun.filter(test => !test.options.skip);
    
    if (testsToRun.length === 0) {
      console.log("Nenhum teste para executar.");
      return {
        total: 0,
        passed: 0,
        failed: 0,
        skipped: 0,
        duration: 0,
        results: []
      };
    }
    
    console.log(`Executando ${testsToRun.length} testes...`);
    
    const startTime = Date.now();
    
    if (parallel) {
      // Executa os testes em paralelo com limite de concorrência
      for (let i = 0; i < testsToRun.length; i += concurrency) {
        const batch = testsToRun.slice(i, i + concurrency);
        const promises = batch.map(test => this._runTest(test));
        
        await Promise.all(promises);
        
        if (this.stopOnError && this.testResults.some(result => !result.passed)) {
          break;
        }
      }
    } else {
      // Executa os testes sequencialmente
      for (const test of testsToRun) {
        await this._runTest(test);
        
        if (this.stopOnError && this.testResults.some(result => !result.passed)) {
          break;
        }
      }
    }
    
    const endTime = Date.now();
    const duration = endTime - startTime;
    
    // Gera o relatório
    const passed = this.testResults.filter(result => result.passed).length;
    const failed = this.testResults.filter(result => !result.passed).length;
    const skipped = this.tests.size - testsToRun.length;
    
    const summary = {
      total: this.testResults.length,
      passed,
      failed,
      skipped,
      duration,
      results: this.testResults
    };
    
    this._printSummary(summary);
    
    return summary;
  }
  
  /**
   * Executa um único teste
   * @param {Object} test - Teste a ser executado
   * @returns {Promise<Object>} - Resultado do teste
   * @private
   */
  async _runTest(test) {
    const { name, fn, options } = test;
    
    if (this.verbose) {
      console.log(`\nExecutando teste: ${name}`);
    }
    
    const result = {
      name,
      category: options.category,
      passed: false,
      duration: 0,
      error: null,
      output: null
    };
    
    const startTime = Date.now();
    
    try {
      // Executa o teste com timeout
      const testPromise = fn.call(this);
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error(`Timeout: O teste excedeu o limite de ${options.timeout}ms.`)), options.timeout);
      });
      
      const output = await Promise.race([testPromise, timeoutPromise]);
      
      result.passed = true;
      result.output = output;
      
      if (this.verbose) {
        console.log(`✓ Teste passou: ${name}`);
      }
    } catch (err) {
      result.passed = false;
      result.error = {
        message: err.message,
        stack: err.stack
      };
      
      if (this.verbose) {
        console.error(`✗ Teste falhou: ${name}`);
        console.error(`  Erro: ${err.message}`);
      }
    }
    
    const endTime = Date.now();
    result.duration = endTime - startTime;
    
    this.testResults.push(result);
    return result;
  }
  
  /**
   * Imprime o resumo dos testes
   * @param {Object} summary - Resumo dos testes
   * @private
   */
  _printSummary(summary) {
    console.log("\n=== Resumo dos Testes ===");
    console.log(`Total: ${summary.total}`);
    console.log(`Passou: ${summary.passed}`);
    console.log(`Falhou: ${summary.failed}`);
    console.log(`Pulou: ${summary.skipped}`);
    console.log(`Duração: ${summary.duration}ms`);
    
    if (summary.failed > 0) {
      console.log("\nTestes que falharam:");
      
      for (const result of summary.results) {
        if (!result.passed) {
          console.log(`- ${result.name}`);
          console.log(`  Erro: ${result.error.message}`);
        }
      }
    }
  }
  
  /**
   * Gera um relatório HTML dos testes
   * @param {string} outputPath - Caminho do arquivo de saída
   * @returns {Promise<string>} - Caminho do arquivo gerado
   */
  async generateReport(outputPath = null) {
    const reportPath = outputPath || path.join(this.outputDir, "test-report.html");
    
    // Calcula estatísticas
    const total = this.testResults.length;
    const passed = this.testResults.filter(result => result.passed).length;
    const failed = this.testResults.filter(result => !result.passed).length;
    const passRate = total > 0 ? Math.round((passed / total) * 100) : 0;
    
    // Agrupa por categoria
    const categories = {};
    
    for (const result of this.testResults) {
      const category = result.category || "general";
      
      if (!categories[category]) {
        categories[category] = {
          name: category,
          total: 0,
          passed: 0,
          failed: 0,
          results: []
        };
      }
      
      categories[category].total++;
      categories[category].passed += result.passed ? 1 : 0;
      categories[category].failed += result.passed ? 0 : 1;
      categories[category].results.push(result);
    }
    
    // Gera o HTML
    const html = `
<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Relatório de Testes - @cognima/banners</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      line-height: 1.6;
      color: #333;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }
    h1, h2, h3 {
      color: #444;
    }
    .summary {
      display: flex;
      justify-content: space-between;
      background-color: #f5f5f5;
      padding: 20px;
      border-radius: 5px;
      margin-bottom: 20px;
    }
    .summary-item {
      text-align: center;
    }
    .summary-item h3 {
      margin: 0;
    }
    .summary-item p {
      font-size: 24px;
      font-weight: bold;
      margin: 10px 0;
    }
    .progress-bar {
      height: 20px;
      background-color: #e0e0e0;
      border-radius: 10px;
      margin-bottom: 20px;
      overflow: hidden;
    }
    .progress {
      height: 100%;
      background-color: #4CAF50;
      border-radius: 10px;
    }
    .category {
      margin-bottom: 30px;
      border: 1px solid #ddd;
      border-radius: 5px;
      overflow: hidden;
    }
    .category-header {
      background-color: #f5f5f5;
      padding: 10px 20px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .category-body {
      padding: 0 20px;
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }
    .category-body.open {
      max-height: 2000px;
      padding: 20px;
    }
    .test-item {
      margin-bottom: 15px;
      padding: 15px;
      border-radius: 5px;
    }
    .test-passed {
      background-color: #e8f5e9;
      border-left: 5px solid #4CAF50;
    }
    .test-failed {
      background-color: #ffebee;
      border-left: 5px solid #f44336;
    }
    .test-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 10px;
    }
    .test-name {
      font-weight: bold;
    }
    .test-duration {
      color: #777;
    }
    .test-error {
      background-color: #fff;
      padding: 10px;
      border-radius: 5px;
      margin-top: 10px;
      white-space: pre-wrap;
      font-family: monospace;
    }
    .badge {
      display: inline-block;
      padding: 3px 8px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: bold;
      color: white;
    }
    .badge-success {
      background-color: #4CAF50;
    }
    .badge-danger {
      background-color: #f44336;
    }
    .timestamp {
      text-align: right;
      color: #777;
      margin-top: 30px;
    }
  </style>
</head>
<body>
  <h1>Relatório de Testes - @cognima/banners</h1>
  
  <div class="summary">
    <div class="summary-item">
      <h3>Total</h3>
      <p>${total}</p>
    </div>
    <div class="summary-item">
      <h3>Passou</h3>
      <p style="color: #4CAF50">${passed}</p>
    </div>
    <div class="summary-item">
      <h3>Falhou</h3>
      <p style="color: #f44336">${failed}</p>
    </div>
    <div class="summary-item">
      <h3>Taxa de Sucesso</h3>
      <p>${passRate}%</p>
    </div>
  </div>
  
  <div class="progress-bar">
    <div class="progress" style="width: ${passRate}%"></div>
  </div>
  
  <h2>Resultados por Categoria</h2>
  
  ${Object.values(categories).map(category => `
    <div class="category">
      <div class="category-header" onclick="toggleCategory('${category.name}')">
        <h3>${category.name}</h3>
        <div>
          <span class="badge badge-success">${category.passed}</span>
          <span class="badge badge-danger">${category.failed}</span>
        </div>
      </div>
      <div id="${category.name}" class="category-body">
        ${category.results.map(result => `
          <div class="test-item ${result.passed ? 'test-passed' : 'test-failed'}">
            <div class="test-header">
              <span class="test-name">${result.name}</span>
              <span class="test-duration">${result.duration}ms</span>
            </div>
            ${!result.passed ? `
              <div class="test-error">
                ${result.error.message}
              </div>
            ` : ''}
          </div>
        `).join('')}
      </div>
    </div>
  `).join('')}
  
  <div class="timestamp">
    Gerado em: ${new Date().toLocaleString()}
  </div>
  
  <script>
    function toggleCategory(id) {
      const element = document.getElementById(id);
      element.classList.toggle('open');
    }
    
    // Abre categorias com falhas automaticamente
    document.addEventListener('DOMContentLoaded', function() {
      ${Object.values(categories)
        .filter(category => category.failed > 0)
        .map(category => `document.getElementById('${category.name}').classList.add('open');`)
        .join('\n      ')}
    });
  </script>
</body>
</html>
    `;
    
    // Salva o relatório
    fs.writeFileSync(reportPath, html);
    
    return reportPath;
  }
  
  /**
   * Salva uma imagem de teste
   * @param {Buffer} imageData - Dados da imagem
   * @param {string} name - Nome do arquivo
   * @returns {Promise<string>} - Caminho do arquivo salvo
   */
  async saveTestImage(imageData, name) {
    const fileName = `${name}-${Date.now()}.png`;
    const filePath = path.join(this.outputDir, fileName);
    
    fs.writeFileSync(filePath, imageData);
    
    return filePath;
  }
  
  /**
   * Compara duas imagens
   * @param {Buffer|string} image1 - Primeira imagem (buffer ou caminho)
   * @param {Buffer|string} image2 - Segunda imagem (buffer ou caminho)
   * @param {Object} options - Opções de comparação
   * @returns {Promise<Object>} - Resultado da comparação
   */
  async compareImages(image1, image2, options = {}) {
    // Implementação simplificada - em um cenário real, usaríamos
    // bibliotecas como pixelmatch ou resemblejs para comparação real
    
    // Carrega as imagens se forem caminhos
    const img1Buffer = typeof image1 === "string" ? fs.readFileSync(image1) : image1;
    const img2Buffer = typeof image2 === "string" ? fs.readFileSync(image2) : image2;
    
    // Compara os tamanhos dos buffers como uma aproximação muito básica
    const sizeDiff = Math.abs(img1Buffer.length - img2Buffer.length);
    const sizeRatio = Math.min(img1Buffer.length, img2Buffer.length) / Math.max(img1Buffer.length, img2Buffer.length);
    
    // Considera as imagens "iguais" se a diferença de tamanho for pequena
    const threshold = options.threshold || 0.05; // 5% de diferença por padrão
    const match = sizeRatio > (1 - threshold);
    
    return {
      match,
      difference: 1 - sizeRatio,
      details: {
        size1: img1Buffer.length,
        size2: img2Buffer.length,
        sizeDiff
      }
    };
  }
  
  /**
   * Cria um teste de banner
   * @param {Function} bannerGenerator - Função geradora de banner
   * @param {Object} params - Parâmetros para o banner
   * @param {Object} options - Opções do teste
   * @returns {Function} - Função de teste
   */
  createBannerTest(bannerGenerator, params, options = {}) {
    const {
      name = "Banner Test",
      saveOutput = true,
      compareWithReference = false,
      referencePath = null,
      threshold = 0.05
    } = options;
    
    return async () => {
      try {
        // Gera o banner
        const buffer = await bannerGenerator(params);
        
        if (!buffer || !(buffer instanceof Buffer)) {
          throw new Error("O gerador de banner não retornou um buffer válido.");
        }
        
        // Salva a saída se necessário
        let outputPath = null;
        
        if (saveOutput) {
          outputPath = await this.saveTestImage(buffer, name.replace(/\s+/g, "-").toLowerCase());
        }
        
        // Compara com a referência se necessário
        let comparisonResult = null;
        
        if (compareWithReference && referencePath) {
          comparisonResult = await this.compareImages(buffer, referencePath, { threshold });
          
          if (!comparisonResult.match) {
            throw new Error(`O banner gerado não corresponde à referência. Diferença: ${comparisonResult.difference * 100}%`);
          }
        }
        
        return {
          success: true,
          outputPath,
          comparisonResult
        };
      } catch (err) {
        this.errorHandler.log("error", `Falha no teste de banner: ${name}`, {
          message: err.message,
          params
        });
        
        throw err;
      }
    };
  }
  
  /**
   * Cria um conjunto de testes de banner
   * @param {Function} bannerGenerator - Função geradora de banner
   * @param {Array<Object>} testCases - Casos de teste
   * @param {Object} options - Opções dos testes
   * @returns {Object} - Conjunto de testes
   */
  createBannerTestSuite(bannerGenerator, testCases, options = {}) {
    const tests = {};
    
    for (const testCase of testCases) {
      const { name, params, ...testOptions } = testCase;
      
      tests[name] = {
        fn: this.createBannerTest(bannerGenerator, params, {
          name,
          ...options,
          ...testOptions
        }),
        options: {
          category: options.category || "banner",
          ...testOptions
        }
      };
    }
    
    return tests;
  }
}

module.exports = TestRunner;

