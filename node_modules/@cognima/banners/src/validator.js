"use strict";

/**
 * Módulo de Validação
 * 
 * Este módulo fornece funcionalidades para validação de parâmetros
 * e entradas no módulo de banners.
 * 
 * @author Cognima Team (melhorado)
 * @version 2.0.0
 */

Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Classe para validação de parâmetros
 */
class Validator {
  /**
   * Cria uma nova instância do validador
   */
  constructor() {
    this.errors = [];
  }
  
  /**
   * Limpa os erros acumulados
   */
  clearErrors() {
    this.errors = [];
  }
  
  /**
   * Obtém os erros acumulados
   * @returns {Array<Object>} - Lista de erros
   */
  getErrors() {
    return [...this.errors];
  }
  
  /**
   * Verifica se há erros acumulados
   * @returns {boolean} - Se há erros
   */
  hasErrors() {
    return this.errors.length > 0;
  }
  
  /**
   * Adiciona um erro
   * @param {string} field - Campo com erro
   * @param {string} message - Mensagem de erro
   * @param {*} value - Valor inválido
   */
  addError(field, message, value = undefined) {
    this.errors.push({
      field,
      message,
      value: value !== undefined ? String(value) : undefined
    });
  }
  
  /**
   * Valida se um valor é obrigatório
   * @param {*} value - Valor a ser validado
   * @param {string} field - Nome do campo
   * @returns {boolean} - Se o valor é válido
   */
  required(value, field) {
    if (value === undefined || value === null || value === "") {
      this.addError(field, `O campo ${field} é obrigatório.`);
      return false;
    }
    return true;
  }
  
  /**
   * Valida se um valor é uma string
   * @param {*} value - Valor a ser validado
   * @param {string} field - Nome do campo
   * @returns {boolean} - Se o valor é válido
   */
  isString(value, field) {
    if (value !== undefined && value !== null && typeof value !== "string") {
      this.addError(field, `O campo ${field} deve ser uma string.`, value);
      return false;
    }
    return true;
  }
  
  /**
   * Valida se um valor é um número
   * @param {*} value - Valor a ser validado
   * @param {string} field - Nome do campo
   * @returns {boolean} - Se o valor é válido
   */
  isNumber(value, field) {
    if (value !== undefined && value !== null && typeof value !== "number") {
      this.addError(field, `O campo ${field} deve ser um número.`, value);
      return false;
    }
    return true;
  }
  
  /**
   * Valida se um valor é um booleano
   * @param {*} value - Valor a ser validado
   * @param {string} field - Nome do campo
   * @returns {boolean} - Se o valor é válido
   */
  isBoolean(value, field) {
    if (value !== undefined && value !== null && typeof value !== "boolean") {
      this.addError(field, `O campo ${field} deve ser um booleano.`, value);
      return false;
    }
    return true;
  }
  
  /**
   * Valida se um valor é um objeto
   * @param {*} value - Valor a ser validado
   * @param {string} field - Nome do campo
   * @returns {boolean} - Se o valor é válido
   */
  isObject(value, field) {
    if (value !== undefined && value !== null && (typeof value !== "object" || Array.isArray(value))) {
      this.addError(field, `O campo ${field} deve ser um objeto.`, value);
      return false;
    }
    return true;
  }
  
  /**
   * Valida se um valor é um array
   * @param {*} value - Valor a ser validado
   * @param {string} field - Nome do campo
   * @returns {boolean} - Se o valor é válido
   */
  isArray(value, field) {
    if (value !== undefined && value !== null && !Array.isArray(value)) {
      this.addError(field, `O campo ${field} deve ser um array.`, value);
      return false;
    }
    return true;
  }
  
  /**
   * Valida se um valor está dentro de um intervalo
   * @param {number} value - Valor a ser validado
   * @param {number} min - Valor mínimo
   * @param {number} max - Valor máximo
   * @param {string} field - Nome do campo
   * @returns {boolean} - Se o valor é válido
   */
  inRange(value, min, max, field) {
    if (value !== undefined && value !== null) {
      if (typeof value !== "number") {
        this.addError(field, `O campo ${field} deve ser um número.`, value);
        return false;
      }
      
      if (value < min || value > max) {
        this.addError(field, `O campo ${field} deve estar entre ${min} e ${max}.`, value);
        return false;
      }
    }
    return true;
  }
  
  /**
   * Valida se um valor tem um comprimento dentro de um intervalo
   * @param {string|Array} value - Valor a ser validado
   * @param {number} min - Comprimento mínimo
   * @param {number} max - Comprimento máximo
   * @param {string} field - Nome do campo
   * @returns {boolean} - Se o valor é válido
   */
  lengthInRange(value, min, max, field) {
    if (value !== undefined && value !== null) {
      if (typeof value !== "string" && !Array.isArray(value)) {
        this.addError(field, `O campo ${field} deve ser uma string ou um array.`, value);
        return false;
      }
      
      if (value.length < min || value.length > max) {
        this.addError(field, `O campo ${field} deve ter entre ${min} e ${max} caracteres.`, value);
        return false;
      }
    }
    return true;
  }
  
  /**
   * Valida se um valor está em uma lista de valores permitidos
   * @param {*} value - Valor a ser validado
   * @param {Array} allowedValues - Lista de valores permitidos
   * @param {string} field - Nome do campo
   * @returns {boolean} - Se o valor é válido
   */
  oneOf(value, allowedValues, field) {
    if (value !== undefined && value !== null && !allowedValues.includes(value)) {
      this.addError(field, `O campo ${field} deve ser um dos seguintes valores: ${allowedValues.join(", ")}.`, value);
      return false;
    }
    return true;
  }
  
  /**
   * Valida se um valor é uma cor hexadecimal válida
   * @param {string} value - Valor a ser validado
   * @param {string} field - Nome do campo
   * @returns {boolean} - Se o valor é válido
   */
  isHexColor(value, field) {
    if (value !== undefined && value !== null) {
      if (typeof value !== "string") {
        this.addError(field, `O campo ${field} deve ser uma string.`, value);
        return false;
      }
      
      const hexColorRegex = /^#([A-Fa-f0-9]{3}|[A-Fa-f0-9]{6})$/;
      
      if (!hexColorRegex.test(value)) {
        this.addError(field, `O campo ${field} deve ser uma cor hexadecimal válida (ex: #FFF ou #FFFFFF).`, value);
        return false;
      }
    }
    return true;
  }
  
  /**
   * Valida se um valor é uma URL válida
   * @param {string} value - Valor a ser validado
   * @param {string} field - Nome do campo
   * @returns {boolean} - Se o valor é válido
   */
  isUrl(value, field) {
    if (value !== undefined && value !== null) {
      if (typeof value !== "string") {
        this.addError(field, `O campo ${field} deve ser uma string.`, value);
        return false;
      }
      
      try {
        new URL(value);
        return true;
      } catch (err) {
        this.addError(field, `O campo ${field} deve ser uma URL válida.`, value);
        return false;
      }
    }
    return true;
  }
  
  /**
   * Valida se um valor é um caminho de arquivo válido
   * @param {string} value - Valor a ser validado
   * @param {string} field - Nome do campo
   * @returns {boolean} - Se o valor é válido
   */
  isFilePath(value, field) {
    if (value !== undefined && value !== null) {
      if (typeof value !== "string") {
        this.addError(field, `O campo ${field} deve ser uma string.`, value);
        return false;
      }
      
      // Validação básica de caminho de arquivo
      const invalidChars = /[<>:"|?*\x00-\x1F]/g;
      
      if (invalidChars.test(value)) {
        this.addError(field, `O campo ${field} contém caracteres inválidos para um caminho de arquivo.`, value);
        return false;
      }
    }
    return true;
  }
  
  /**
   * Valida se um valor corresponde a um padrão regex
   * @param {string} value - Valor a ser validado
   * @param {RegExp} pattern - Padrão regex
   * @param {string} field - Nome do campo
   * @param {string} message - Mensagem de erro personalizada
   * @returns {boolean} - Se o valor é válido
   */
  matches(value, pattern, field, message = null) {
    if (value !== undefined && value !== null) {
      if (typeof value !== "string") {
        this.addError(field, `O campo ${field} deve ser uma string.`, value);
        return false;
      }
      
      if (!pattern.test(value)) {
        this.addError(field, message || `O campo ${field} não corresponde ao padrão esperado.`, value);
        return false;
      }
    }
    return true;
  }
  
  /**
   * Valida se um objeto tem uma estrutura específica
   * @param {Object} value - Objeto a ser validado
   * @param {Object} schema - Esquema de validação
   * @param {string} field - Nome do campo
   * @returns {boolean} - Se o objeto é válido
   */
  validateObject(value, schema, field) {
    if (value !== undefined && value !== null) {
      if (typeof value !== "object" || Array.isArray(value)) {
        this.addError(field, `O campo ${field} deve ser um objeto.`, value);
        return false;
      }
      
      let isValid = true;
      
      for (const key in schema) {
        const subField = field ? `${field}.${key}` : key;
        const validator = schema[key];
        
        if (typeof validator === "function") {
          isValid = validator.call(this, value[key], subField) && isValid;
        } else if (typeof validator === "object" && !Array.isArray(validator)) {
          isValid = this.validateObject(value[key], validator, subField) && isValid;
        }
      }
      
      return isValid;
    }
    return true;
  }
  
  /**
   * Valida se um array tem itens válidos
   * @param {Array} value - Array a ser validado
   * @param {Function} itemValidator - Função de validação para cada item
   * @param {string} field - Nome do campo
   * @returns {boolean} - Se o array é válido
   */
  validateArray(value, itemValidator, field) {
    if (value !== undefined && value !== null) {
      if (!Array.isArray(value)) {
        this.addError(field, `O campo ${field} deve ser um array.`, value);
        return false;
      }
      
      let isValid = true;
      
      for (let i = 0; i < value.length; i++) {
        const subField = `${field}[${i}]`;
        isValid = itemValidator.call(this, value[i], subField) && isValid;
      }
      
      return isValid;
    }
    return true;
  }
  
  /**
   * Valida um conjunto de parâmetros
   * @param {Object} params - Parâmetros a serem validados
   * @param {Object} rules - Regras de validação
   * @returns {boolean} - Se os parâmetros são válidos
   */
  validate(params, rules) {
    this.clearErrors();
    
    let isValid = true;
    
    for (const field in rules) {
      const value = params[field];
      const fieldRules = rules[field];
      
      for (const rule of fieldRules) {
        const { type, ...options } = rule;
        
        switch (type) {
          case "required":
            isValid = this.required(value, field) && isValid;
            break;
          case "string":
            isValid = this.isString(value, field) && isValid;
            break;
          case "number":
            isValid = this.isNumber(value, field) && isValid;
            break;
          case "boolean":
            isValid = this.isBoolean(value, field) && isValid;
            break;
          case "object":
            isValid = this.isObject(value, field) && isValid;
            break;
          case "array":
            isValid = this.isArray(value, field) && isValid;
            break;
          case "range":
            isValid = this.inRange(value, options.min, options.max, field) && isValid;
            break;
          case "length":
            isValid = this.lengthInRange(value, options.min, options.max, field) && isValid;
            break;
          case "oneOf":
            isValid = this.oneOf(value, options.values, field) && isValid;
            break;
          case "hexColor":
            isValid = this.isHexColor(value, field) && isValid;
            break;
          case "url":
            isValid = this.isUrl(value, field) && isValid;
            break;
          case "filePath":
            isValid = this.isFilePath(value, field) && isValid;
            break;
          case "regex":
            isValid = this.matches(value, options.pattern, field, options.message) && isValid;
            break;
          case "custom":
            if (typeof options.validator === "function") {
              const result = options.validator(value, field);
              
              if (result !== true) {
                this.addError(field, options.message || result || `O campo ${field} é inválido.`, value);
                isValid = false;
              }
            }
            break;
        }
        
        // Se o campo é obrigatório e inválido, não continua validando
        if (rule.type === "required" && !isValid) {
          break;
        }
      }
    }
    
    return isValid;
  }
}

module.exports = Validator;

